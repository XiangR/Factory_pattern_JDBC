# Factory_pattern_JDBC
设计模式使用在JDBC

	1. 首先对于一个带有实体的数据库 我们要创建一个domain对象 （第一层的对于数据库的封装）
		1. 创建一个新的包 用来存放User对象  .domain

	2. 接下来我们要定义一个接口 ,数据访问的接口， 给业务逻辑层使用，来进行增删改查的操作
		1. 创建一个新的包 .dao  用来存放接口
		2. 其实我思考了一下  我们可以不使用接口， 而直接创建一个 类于UserDaoJdbcImpl的业务逻辑层对 上面的对象进行直接的操作 。但是这里使用接口进行二次封装的意义就在于：我们可以很明了的知道我们下面将要对这个Users（或是数据库中的表）进行什么样的操作，而我们以后想要为这个对象进行其他的操作的时候我们只需要在接口中定义新的方法，然后在实现接口的业务逻辑层对这个方法进行实现就可以了。
		3. 而使用的时候  我们只需要new出这个接口然后对其进行传参调用就可以了

	3. 为这个接口创建一个实现
		1. 我们同样创建一个新的包来完成 .dao.mp
		2. 在我们去实现的时候我们遇到了问题 关于异常（important）
			1. 首先这里在实现的时候因为使用到了 SQL 语句进行提取数据 所以还是会存在异常。以前的情况我们都会选择抛出他，但是现在不行了。借着Server 层对这里的dao.mp 的使用。若是不对这里的异常进行处理的话，以后再用户进行如注册等操作的时候会遇到很大的麻烦。所以引出了下面
			2. 我们碰到的异常不能再只是抛出了，这也我们在上层时还要抛出，没有任何意义，而且还会造成接口的污染（因为声明接口的时候，我们没有并没有声明抛出异常，所以所有实现接口的方法都不能做出超出接口域的操作）。更重要的是若是我们在这里抛出了，那么对于 SQL 这样的编译时异常 我们在上次的Server层进行操作的时候我们还是要catch住这个异常（而且catch住了也不能解决）而且这和我们以后的架构迁移：比如讲 JDBC切换成 Hibernate（而Hibernate是没有sql异常的，那么久无法实现迁移了）
			3. 而若我们只是 catch之后 没有进行处理的话 也不行因为那样的话会使我们在运行其他类的时候使错误转移
			4. 这个时候我们想到的  将 SQL的编译时异常改成运行时异常
				1. 我们在 .dao的包里传建一个 我 exception的类 继承自 runtimeexception

			5. 这是我们只需要在 异常的地方去 throw new DaoException(e.getMessage(), e);   因为我们将编译时异常改为了运行时异常则这样就可以抛出了。这样在上次的Server使用接口的实现类的时候 它就可以选择性的catch 了  。若是她认为他可以处理那么它就可以catch 若是不能处理则可以直接不管


	4. 最后提到了一个很有牛逼的方法  重构
		1. 对于那些有较高重复次数的 代码段 我我们可以使用重构的方式

	5. 最后我们为了更好地复用性，选择了工厂模式
		1. 我们的希望是我们的UserDaoTest类不需要具体类的实现（若是我们切换架构也不会受到影响，于是我们引出工厂类）参考下面的红色加粗字体：我们在new 出一个实际的UserDao的实例的时候完全没有去使用一些具体类
		2. 下面是工厂类的实现：
			1. 我们可以新建一个 配置文件properties 来对我们的数据进行储存
			2. 随后我们新建一个DaoFactory 在这里我们可以通过配置文件的形式来寻找到我们需要初始化的类名（这里也有一个很详细的理解 （在我们的笔记上有详细的介绍）去复习）
			3. 然后使用反射即可以将得到的类名初始化为一个类（这是一个很重要的学习）
			4. 这样若是我们想更改数据访问层比如说 将UserDaoImpl -> UserDaoHibernate 我们只需要在 配置文件中进行更改那么一切就OK了（其他的什么都不变）就完全的切换了底层的数据访问层


